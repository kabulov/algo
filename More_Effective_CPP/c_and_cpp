
NAME MANGLING

extern "C" {
  void first_func();
  int second_fund(int a, double b);
}

extern "C" void abc();

extern "C" - tells compiler not to mangle the name of a function

#ifdef __cplusplus
 extern "C" {
#endif
  void drawLine(int x1, int y1, int x2, int y2);
  void twiddleBits(unsigned char bits);
  void simulate(int iterations);
#ifdef __cplusplus
 }
#endif

STATIC INITIALIZATION

objects at global, file scope and constructors of static class objects 
are called before before the body of main is executed

int main(int argc, char *argv[])
{
  performStaticInitialization(); // generated by the implementation
  //the statements you put in main go here;
  performStaticDestruction(); // generated by the implementation
}

If at all possible, write main in C++.

DYNAMIC MEMORY ALLOCAITON

char * strdup(const char *ps); // return a copy of the
// string pointed to by ps
If a memory leak is to be avoided, the memory allocated inside strdup
must be deallocated by strdupâ€™s caller. But how is the memory to be
deallocated? By using delete? By calling free?

DATA STRUCTURE COMPATIBILITY

From a data structure perspective, it boils down to this: it is safe to
pass data structures from C++ to C and from C to C++ provided the
definition of those structures compiles in both C++ and C.

