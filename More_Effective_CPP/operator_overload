
class Rational {
public:
  operator double() const {}
};

//also implicit constructors ^

class Array {
public:
	class ArraySize {
	public:
		ArraySize(int sz):size_(sz) {}
		int size() const {return size_;};
	private:
		int size_;
	};
	explicit Array(ArraySize s) {}
};

//proxy class, to prevent more than one user defined implicit conversion ^

class Int {
public:
	Int& operator++();
	const Int operator++(int);
	
	Int& operator--();
	const Int operator--(int);
	
	Int& operator+=(const Int& other); //or just int to add 1 
};

Int& Int::operator++() {
	(*this) += 1; // = *this + 1
	return *this;
}

const Int Int::operator++(int) {
	const Int oldVal = *this;
	++(*this);
	return oldVal;
}

//never overload || or &&
//never overload ,
//http://stackoverflow.com/questions/1485983/calling-c-class-methods-via-a-function-pointer

cannot overload
1. all 4 casts
2. new, delete, sizeof, typeid
3. ., .*, ::, ?:

Reasonable or not, there are rules to this C++ game, and one of them
is that every overloaded operator must take at least one argument of a
user-defined type. int isn’t a user-defined type, so we can’t overload
an operator taking only arguments of that type. (If this rule didn’t exist,
programmers would be able to change the meaning of predefined
operations, and that would surely lead to chaos. For example, the attempted
overloading of operator+ above would change the meaning of
addition on ints. Is that really something we want people to be able to
do?)
